#version 450

#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_scalar_block_layout: require

struct CullData
{
	mat4 view;

	float P00, P11, znear, zfar; // symmetric projection parameters
	float frustum[4]; // data for left/right/top/bottom frustum planes
	uint meshCount;
};

struct MeshDrawCommand
{
	// VkDrawIndexedIndirectCommand
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

struct Mesh
{
	vec3 minAABB;
    uint indexCount;
    vec3 maxAABB;
    uint firstIndex;
    uint vertexOffset;
};

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform block{
    CullData cullData;
};

layout(std430, set = 0, binding = 0) buffer readonly Meshes
{
	Mesh meshes[];
};

layout(std430, set = 0, binding = 1) buffer writeonly CommandBuffer
{
	MeshDrawCommand commands[];
};

layout(std430, set = 0, binding = 2) uniform GlobalUniform
{
	mat4 transforms[];
};


bool check_is_visible(mat4 transform, vec3 minAABB, vec3 maxAABB)
{
	
	return true;
}


void main() 
{
    uint id = gl_GlobalInvocationID.x;
	if (id >= cullData.meshCount)
	{
		return;
	}
	Mesh mesh = meshes[id];
	//commands[id].drawId = id;
	commands[id].indexCount = mesh.indexCount;
	commands[id].instanceCount = 1;
	commands[id].firstIndex = mesh.firstIndex;
	commands[id].vertexOffset = mesh.vertexOffset;
	commands[id].firstInstance = 0;

	// ModelInformation model                    = model_buffer.arr[id];
	// bool             is_visible               = check_is_visible(global_uniform.transform, vec3(1.0), vec3(1.0));
	// command_buffer.commands[id].instanceCount = is_visible ? 1 : 0;
}
